{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Wireless Communication Documentation","text":"<p>Welcome to the Wireless Communication documentation! This resource is designed to provide a comprehensive and accessible guide to key concepts, algorithms, and techniques in wireless communications.</p>"},{"location":"#purpose","title":"Purpose","text":"<p>The primary goal of this documentation is to:</p> <ul> <li>Share knowledge about wireless communication principles and algorithms.</li> <li>Provide step-by-step explanations of key concepts like MMSE, ZF, and NOMA.</li> <li>Enable practical understanding through Python/Matlab examples.</li> </ul>"},{"location":"#topics-covered","title":"Topics Covered","text":"<p>This documentation is organized into the following sections:</p>"},{"location":"#1-channel-models","title":"1. Channel Models","text":"<ul> <li>Overview of wireless channel characteristics, including:<ul> <li>Fading models (Rayleigh, Rician).</li> <li>Path loss and shadowing.</li> </ul> </li> <li>Simulation techniques to model real-world environments.</li> </ul>"},{"location":"#2-multiple-access-techniques","title":"2. Multiple Access Techniques","text":"<ul> <li>Techniques to enable efficient spectrum sharing, such as:<ul> <li>Orthogonal methods (OFDMA, TDMA, CDMA).</li> <li>Non-orthogonal methods (NOMA, SCMA).</li> </ul> </li> </ul>"},{"location":"#3-beamforming-and-mimo","title":"3. Beamforming and MIMO","text":"<ul> <li>Advanced spatial processing techniques, including:<ul> <li>Zero-Forcing (ZF) beamforming.</li> <li>Minimum Mean Square Error (MMSE) precoding.</li> <li>Massive MIMO and hybrid beamforming.</li> </ul> </li> </ul>"},{"location":"#4-error-correction-codes","title":"4. Error Correction Codes","text":"<ul> <li>Introduction to forward error correction (FEC) techniques:<ul> <li>Turbo Codes, LDPC, and Polar Codes.</li> <li>Applications in 5G and beyond.</li> </ul> </li> </ul>"},{"location":"#5-resource-allocation-algorithms","title":"5. Resource Allocation Algorithms","text":"<ul> <li>Optimization techniques for:<ul> <li>Power control and scheduling.</li> <li>Fairness and energy efficiency in wireless networks.</li> </ul> </li> </ul>"},{"location":"#6-examples-in-pythonmatlab","title":"6. Examples in Python/Matlab","text":"<ul> <li>Hands-on examples to implement and visualize algorithms, such as:<ul> <li>Simulating MMSE and ZF precoding.</li> <li>Analyzing NOMA performance with Python.</li> </ul> </li> </ul>"},{"location":"#how-to-use-this-documentation","title":"How to Use This Documentation","text":"<ol> <li>Navigate to the topics of interest using the table of contents.</li> <li>Explore detailed explanations, accompanied by mathematical derivations and visual aids.</li> <li>Run the provided Python/Matlab examples to deepen your understanding.</li> </ol>"},{"location":"#contribution","title":"Contribution","text":"<p>This documentation is a living resource. Feedback and contributions are welcome to help improve its content. If you have suggestions or would like to contribute, please visit our GitHub repository.</p> <p>Enjoy learning and exploring wireless communication algorithms!</p>"},{"location":"channel_estimation/","title":"2. Channel Estimation","text":"<p>Accurate channel estimation is essential in wireless communication systems for efficient signal processing, especially in scenarios involving MIMO, OFDM, and beamforming techniques. It allows the transmitter or receiver to acquire knowledge of the channel state information (CSI), which is critical for equalization, interference mitigation, and adaptive modulation.</p>"},{"location":"channel_estimation/#21-what-is-channel-estimation","title":"2.1 What is Channel Estimation?","text":"<p>Channel estimation refers to the process of determining the channel characteristics between the transmitter and receiver. It involves estimating parameters such as:</p> <ul> <li>Path gains and delays.</li> <li>Phase and amplitude distortions.</li> <li>Frequency-selective or time-varying fading.</li> </ul>"},{"location":"channel_estimation/#importance-of-channel-estimation","title":"Importance of Channel Estimation","text":"<ul> <li>Equalization: Removes channel-induced distortions.</li> <li>Beamforming: Requires accurate CSI to align transmitted signals.</li> <li>Adaptive Modulation: Enables the system to dynamically adjust modulation schemes based on channel conditions.</li> </ul>"},{"location":"channel_estimation/#22-channel-estimation-techniques","title":"2.2 Channel Estimation Techniques","text":"<p>Channel estimation methods can be broadly categorized based on the availability of pilot symbols and system assumptions:</p>"},{"location":"channel_estimation/#221-pilot-based-estimation","title":"2.2.1 Pilot-based Estimation","text":"<ul> <li>Pilot Symbols: Predefined symbols known to both transmitter and receiver are periodically inserted into the transmitted signal.</li> <li> <p>Advantages:</p> <ul> <li>Provides accurate CSI for deterministic scenarios.</li> <li>Well-suited for time-invariant or slow-fading channels.</li> </ul> </li> <li> <p>Methods:</p> <ol> <li> <p>Least Squares (LS):</p> <ul> <li>Solves for channel coefficients by minimizing the squared error between received and expected signals.</li> <li> <p>Formula:</p> \\[   \\boldsymbol{Y} = \\boldsymbol{X}\\boldsymbol{H} + \\boldsymbol{Z} \\] <p>where \\(\\boldsymbol{Y}\\) is the received signal, \\(\\boldsymbol{X}\\) is the pilot symbol (diagonal matrix), \\(\\boldsymbol{Z}\\) is the noise, and \\(\\boldsymbol{H}\\) is the channel.</p> \\[ \\begin{aligned} J(\\hat{\\boldsymbol{H}}) &amp; =\\|\\boldsymbol{Y}-\\boldsymbol{X} \\hat{\\boldsymbol{H}}\\|^2 \\\\ &amp; =(\\boldsymbol{Y}-\\boldsymbol{X} \\hat{\\boldsymbol{H}})^{\\mathrm{H}}(\\boldsymbol{Y}-\\boldsymbol{X} \\hat{\\boldsymbol{H}}) \\\\ &amp; =\\boldsymbol{Y}^{\\mathrm{H}} \\boldsymbol{Y}-\\boldsymbol{Y}^{\\mathrm{H}} \\boldsymbol{X} \\hat{\\boldsymbol{H}}-\\hat{\\boldsymbol{H}}^{\\mathrm{H}} \\boldsymbol{X}^{\\mathrm{H}} \\boldsymbol{Y}+\\hat{\\boldsymbol{H}}^{\\mathrm{H}} \\boldsymbol{X}^{\\mathrm{H}} \\boldsymbol{X} \\hat{\\boldsymbol{H}}. \\end{aligned} \\] <p>Let the partial derivative of \\(J(\\hat{\\boldsymbol{H}})\\) with respect to \\(\\hat{\\boldsymbol{H}}\\) be equal to 0,</p> \\[ \\frac{\\partial J(\\hat{\\boldsymbol{H}})}{\\partial \\hat{\\boldsymbol{H}}}=-2\\left(\\boldsymbol{X}^{\\mathrm{H}} \\boldsymbol{Y}\\right)^*+2\\left(\\boldsymbol{X}^{\\mathrm{H}} \\boldsymbol{X} \\hat{\\boldsymbol{H}}\\right)^*=0. \\] <p>Then, we can get the solution of LS,</p> <p>$$\\hat{\\boldsymbol{H}}_{\\mathrm{LS}}=\\left(\\boldsymbol{X}^{\\mathrm{H}} \\boldsymbol{X}\\right)^{-1} \\boldsymbol{X}^{\\mathrm{H}} \\boldsymbol{Y}=\\boldsymbol{X}^{-1} \\boldsymbol{Y},  $$</p> <p>where \\(\\hat{\\boldsymbol{H}}\\) denots the estimation of \\(\\boldsymbol{H}\\). Furthermore, we can calculate the mean square error (MSE) of LS method as follows:</p> <p>$$   \\begin{aligned}   \\mathrm{MSE}{\\mathrm{LS}} &amp; =E\\left{\\left(\\boldsymbol{H}-\\hat{\\boldsymbol{H}}\\right)\\right} \\   &amp; =E\\left{\\left(\\boldsymbol{H}-\\boldsymbol{X}^{-1} \\boldsymbol{Y}\\right)^{\\mathrm{H}}\\left(\\boldsymbol{H}-\\boldsymbol{X}^{-1} \\boldsymbol{r}\\right)\\right} \\   &amp; =E\\left{\\left(\\boldsymbol{X}^{-1} \\boldsymbol{Z}\\right)^{\\mathrm{H}}\\left(\\boldsymbol{X}^{-1} \\boldsymbol{Z}\\right)\\right} \\   &amp; =E\\left{\\boldsymbol{Z}^{\\mathrm{H}}\\left(\\boldsymbol{X}^{\\mathrm{H}}\\right)^{-1} \\boldsymbol{Z}\\right} \\   &amp; =\\frac{\\sigma_z^2}{\\sigma_x^2}   \\end{aligned}   $$}}\\right)^{\\mathrm{H}}\\left(\\boldsymbol{H}-\\boldsymbol{H}_{\\mathrm{LS}</p> <p>where MSE is inversely proportional to the signal-to-noise (SNR) ratio, \\(\\frac{\\sigma_x^2}{\\sigma_z^2}\\). This implies that the lower SNR, the less effective the LS is, because it amplifies the noise.</p> </li> </ul> </li> <li> <p>Minimum Mean Square Error (MMSE):</p> <ul> <li>Incorporates noise statistics and prior knowledge of the channel.</li> <li>Formula:</li> </ul> <p>$$    \\hat{H}{MMSE} = R_H (R_H + \\sigma^2 I)^{-1} \\hat{H},    $$</p> <p>where \\(R_H\\) is the channel covariance matrix and \\(\\sigma^2\\) is noise variance.</p> </li> </ol> </li> <li> <p>LS vs. MMSE Comparison</p> <ol> <li> <p>Noise Sensitivity:</p> <ul> <li>LS estimation is highly susceptible to noise, especially in low-SNR environments, as it does not account for noise statistics.</li> <li>MMSE estimation leverages noise characteristics to suppress the impact of noise, providing superior accuracy in noisy conditions.</li> </ul> </li> <li> <p>Use of Prior Information:</p> <ul> <li>LS estimation assumes no prior knowledge of the channel and performs a straightforward estimation.</li> <li>MMSE estimation utilizes statistical properties of the channel (e.g., correlation, delay spread), resulting in a more robust estimation.</li> </ul> </li> <li> <p>Complexity:</p> <ul> <li>LS estimation is computationally simple, requiring only a division operation, making it suitable for systems with stringent latency or processing constraints.</li> <li>MMSE estimation involves matrix inversion and requires the covariance matrix, resulting in higher computational complexity.</li> </ul> </li> <li> <p>Mean Square Error (MSE):</p> <ul> <li>LS estimation minimizes instantaneous errors but does not guarantee the smallest MSE.</li> <li>MMSE estimation explicitly minimizes the MSE, ensuring optimal performance in terms of estimation accuracy when channel statistics are available.</li> </ul> </li> </ol> </li> </ul>"},{"location":"channel_estimation/#222-blind-estimation","title":"2.2.2 Blind Estimation","text":"<ul> <li>Description: Estimates the channel without relying on pilot symbols, using the statistical properties of received signals.</li> <li> <p>Advantages:</p> <ul> <li>Higher spectral efficiency due to no overhead for pilot symbols.</li> </ul> </li> <li> <p>Challenges:</p> <ul> <li>Requires a large number of observations for accurate results.</li> <li>Computationally complex.</li> </ul> </li> </ul>"},{"location":"channel_estimation/#223-semi-blind-estimation","title":"2.2.3 Semi-blind Estimation","text":"<ul> <li>Combines pilot-based and blind estimation techniques.</li> <li>Uses pilot symbols for initial estimates and refines them using blind methods.</li> </ul>"},{"location":"channel_estimation/#23-channel-estimation-in-ofdm-systems","title":"2.3 Channel Estimation in OFDM Systems","text":"<p>In OFDM systems, channel estimation faces unique challenges due to: 1. Frequency Selectivity:    - Multipath propagation causes varying gains across subcarriers. 2. Pilot Subcarrier Allocation:    - Pilots are inserted at specific subcarriers to estimate the channel at those frequencies, followed by interpolation for other subcarriers. 3. Interpolation Techniques:    - Linear Interpolation:      - Straightforward but may result in poor accuracy for rapidly changing channels.    - Spline Interpolation:      - Provides smoother transitions for high-variability channels.    - DFT-based Interpolation:      - Exploits the sparsity of the channel in the delay domain.</p>"},{"location":"channel_estimation/#24-python-simulation","title":"2.4 Python Simulation","text":"<p>The following Python code demonstrates LS and MMSE-based channel estimation in an OFDM system.</p>"},{"location":"channel_estimation/#code-implementation","title":"Code Implementation","text":"<pre><code>import numpy as np\nfrom scipy.interpolate import interp1d\n\ndef interpolate(H_est, pilot_loc, Nfft, method):\n    \"\"\"\n    Interpolates the channel estimate over all subcarriers.\n\n    Args:\n        H_est (ndarray): Channel estimate using pilot sequence.\n        pilot_loc (ndarray): Location of pilot sequence.\n        Nfft (int): FFT size.\n        method (str): Interpolation method ('linear' or 'spline').\n\n    Returns:\n        ndarray: Interpolated channel estimate over all subcarriers.\n    \"\"\"\n    # Extend at the beginning if necessary\n    if pilot_loc[0] &gt; 0:\n        slope_start = (H_est[1] - H_est[0]) / (pilot_loc[1] - pilot_loc[0])\n        extrapolated_start = H_est[0] - slope_start * (pilot_loc[0] - 0)\n        H_est = np.insert(H_est, 0, extrapolated_start)\n        pilot_loc = np.insert(pilot_loc, 0, 0)\n\n    # Extend at the end if necessary\n    if pilot_loc[-1] &lt; Nfft - 1:\n        slope_end = (H_est[-1] - H_est[-2]) / (pilot_loc[-1] - pilot_loc[-2])\n        extrapolated_end = H_est[-1] + slope_end * (Nfft - 1 - pilot_loc[-1])\n        H_est = np.append(H_est, extrapolated_end)\n        pilot_loc = np.append(pilot_loc, Nfft - 1)\n\n    # Interpolate\n    if method.lower() == 'linear':\n        interp_fn = interp1d(pilot_loc, H_est, kind='linear', fill_value=\"extrapolate\")\n    else:\n        interp_fn = interp1d(pilot_loc, H_est, kind='cubic', fill_value=\"extrapolate\")\n\n    return interp_fn(np.arange(Nfft))\n\n\ndef ls_channel_estimation(Y, Xp, pilot_loc, Nfft, Nps, int_opt):\n    \"\"\"\n    LS channel estimation function.\n\n    Args:\n        Y (ndarray): Frequency-domain received signal.\n        Xp (ndarray): Pilot signal.\n        pilot_loc (ndarray): Pilot locations.\n        Nfft (int): FFT size.\n        Nps (int): Pilot spacing.\n        int_opt (str): Interpolation method ('linear' or 'spline').\n\n    Returns:\n        ndarray: LS channel estimate.\n    \"\"\"\n    Np = Nfft // Nps  # Number of pilots\n    LS_est = Y[pilot_loc] / Xp  # LS channel estimation\n    H_LS = interpolate(LS_est, pilot_loc, Nfft, int_opt)  # Interpolation\n\n    return H_LS\n\n\ndef mmse_channel_estimation(Y, Xp, pilot_loc, Nfft, Nps, h, SNR_dB):\n    \"\"\"\n    MMSE channel estimation function.\n\n    Args:\n        Y (ndarray): Frequency-domain received signal.\n        Xp (ndarray): Pilot signal.\n        pilot_loc (ndarray): Pilot locations.\n        Nfft (int): FFT size.\n        Nps (int): Pilot spacing.\n        h (ndarray): Channel impulse response.\n        SNR_dB (float): Signal-to-Noise Ratio in dB.\n\n    Returns:\n        ndarray: MMSE channel estimate.\n    \"\"\"\n    snr = 10 ** (SNR_dB / 10)  # Convert SNR to linear scale\n    Np = Nfft // Nps  # Number of pilots\n    H_tilde = Y[pilot_loc] / Xp  # LS estimate\n\n    # Compute RMS delay spread from channel impulse response\n    k = np.arange(len(h))\n    hh = np.sum(h * np.conj(h))\n    tmp = h * np.conj(h) * k\n    r = np.sum(tmp) / hh\n    r2 = np.sum(tmp * k) / hh\n    tau_rms = np.sqrt(r2 - r**2)\n\n    # Frequency-domain correlation\n    df = 1 / Nfft  # Subcarrier spacing\n    j2pi_tau_df = 1j * 2 * np.pi * tau_rms * df\n\n    # Correlation matrices\n    K1 = np.tile(np.arange(Nfft).reshape(-1, 1), (1, Np))\n    K2 = np.tile(np.arange(Np), (Nfft, 1))\n    rf = 1 / (1 + j2pi_tau_df * (K1 - K2 * Nps))\n\n    K3 = np.tile(np.arange(Np).reshape(-1, 1), (1, Np))\n    K4 = np.tile(np.arange(Np), (Np, 1))\n    rf2 = 1 / (1 + j2pi_tau_df * Nps * (K3 - K4))\n\n    Rhp = rf\n    Rpp = rf2 + np.eye(Np) / snr\n    H_MMSE = np.matmul(Rhp, np.linalg.inv(Rpp)).dot(H_tilde)\n\n    return H_MMSE\n</code></pre>"},{"location":"channel_estimation/#25-concludsion","title":"2.5 Concludsion","text":"<p>Channel estimation is a cornerstone of modern wireless communication systems, enabling equalization, beamforming, and adaptive modulation. Techniques like LS and MMSE are widely used due to their simplicity and accuracy, while interpolation methods ensure reliable channel estimates across all subcarriers in OFDM systems.</p>"},{"location":"channel_estimation/#references","title":"References","text":"<ul> <li>Cho, Yong Soo, Jaekwon Kim, Won Y. Yang, and Chung G. Kang. MIMO-OFDM wireless communications with MATLAB. John Wiley &amp; Sons, 2010.</li> </ul>"},{"location":"channel_models/","title":"1. Channel Models","text":"<p>Wireless communication channels are inherently unpredictable and vary across time, frequency, and space due to the dynamic nature of the propagation environment. Accurate channel modeling is essential for designing and evaluating modern communication systems, particularly in 5G and beyond. This chapter provides an overview of wireless channel characteristics, common models, and their simulation techniques.</p>"},{"location":"channel_models/#11-wireless-channel-characteristics","title":"1.1 Wireless Channel Characteristics","text":"<p>Wireless channels exhibit unique characteristics due to the interaction between transmitted signals and the surrounding environment. The primary factors affecting wireless channels are:</p> <p>small-scale fading</p> <p>large-scale fading</p>"},{"location":"channel_models/#111-multipath-propagation","title":"1.1.1 Multipath Propagation","text":"<ul> <li>Definition: Signals from a transmitter reach the receiver via multiple paths caused by reflection, diffraction, and scattering.</li> <li> <p>Impacts:</p> <ul> <li>Constructive or destructive interference: Leads to signal fading.</li> <li>Delay spread: Causes inter-symbol interference (ISI).</li> <li>Frequency selectivity: Variations in channel gain across different frequencies.</li> </ul> </li> </ul>"},{"location":"channel_models/#112-doppler-effect","title":"1.1.2 Doppler Effect","text":"<ul> <li>Definition: Frequency shift caused by the relative motion between transmitter and receiver.</li> <li> <p>Impacts:</p> <ul> <li>Doppler spread: Results in time-selective fading.</li> <li>Coherence time: Defines how long the channel remains static.</li> </ul> </li> </ul>"},{"location":"channel_models/#113-shadowing","title":"1.1.3 Shadowing","text":"<ul> <li>Definition: Signal attenuation caused by large obstacles (e.g., buildings, mountains).</li> <li> <p>Modeling:</p> <ul> <li>Typically modeled as a log-normal distribution over distance.</li> </ul> </li> </ul>"},{"location":"channel_models/#114-path-loss","title":"1.1.4 Path Loss","text":"<ul> <li> <p>Definition: Reduction in signal power as it propagates through space.</p> </li> <li> <p>Impacts:</p> <ul> <li>Determines the communication range.</li> <li>Dominates over large distances.</li> </ul> </li> </ul>"},{"location":"channel_models/#12-wireless-channel-classification","title":"1.2 Wireless Channel Classification","text":"<p>Wireless channels are commonly classified based on their characteristics:</p>"},{"location":"channel_models/#121-classification-by-fading","title":"1.2.1 Classification by Fading","text":"<ol> <li> <p>Flat Fading:</p> <ul> <li>All frequency components of the signal experience the same fading.</li> <li>Occurs when the channel bandwidth is much larger than the signal bandwidth.</li> </ul> </li> <li> <p>Frequency-Selective Fading:</p> <ul> <li>Different frequency components experience different fading.</li> <li>Caused by multipath propagation with delay spread larger than the signal's symbol duration.</li> </ul> </li> </ol>"},{"location":"channel_models/#122-classification-by-time-variability","title":"1.2.2 Classification by Time Variability","text":"<ol> <li> <p>Fast Fading:</p> <ul> <li>Channel changes rapidly within the symbol duration.</li> <li>Caused by high mobility or large Doppler spread.</li> </ul> </li> <li> <p>Slow Fading:</p> <ul> <li>Channel remains constant over several symbol durations.</li> <li>Results from slow environmental changes.</li> </ul> </li> </ol>"},{"location":"channel_models/#123-classification-by-losnlos","title":"1.2.3 Classification by LOS/NLOS","text":"<ol> <li> <p>Line-of-Sight (LOS):</p> <ul> <li>Direct path exists between transmitter and receiver.</li> <li>Typically observed in free-space or rural environments.</li> </ul> </li> <li> <p>Non-Line-of-Sight (NLOS):</p> <ul> <li>No direct path due to obstructions.</li> <li>Common in urban and indoor environments.</li> </ul> </li> </ol>"},{"location":"channel_models/#13-common-channel-models","title":"1.3 Common Channel Models","text":""},{"location":"channel_models/#131-free-space-path-loss-model","title":"1.3.1 Free-Space Path Loss Model","text":"<ul> <li> <p>Description:</p> <ul> <li>Idealized model for LOS communication.</li> <li>Path loss is proportional to the square of the distance.</li> </ul> </li> <li> <p>Path Loss Formula:</p> </li> </ul> <p>$$   PL(d) = 20 \\log_{10}(d) + 20 \\log_{10}(f) + 20 \\log_{10}(\\frac{4\\pi}{c}) \\quad (\\text{dB}),   $$</p> <p>where \\(d\\) denotes distance (in meters), \\(f\\) denotes frequency (in Hz), and \\(c\\) denotes the speed of light (in m/s).</p>"},{"location":"channel_models/#132-rayleigh-fading-model","title":"1.3.2 Rayleigh Fading Model","text":"<ul> <li> <p>Description:</p> <ul> <li>Assumes no dominant LOS path.</li> <li>Signal amplitude follows a Rayleigh distribution.</li> </ul> </li> <li> <p>Applications:</p> <ul> <li>Urban environments with dense scatterers.</li> </ul> </li> <li> <p>Probability Density Function (PDF):</p> </li> </ul> <p>$$   f_R(r) = \\frac{r}{\\sigma^2} e^{-r^2 / (2\\sigma^2)}, \\quad r \\geq 0.   $$</p>"},{"location":"channel_models/#133-rician-fading-model","title":"1.3.3 Rician Fading Model","text":"<ul> <li> <p>Description:</p> <ul> <li>Incorporates both LOS and scattered components.</li> <li>Signal amplitude follows a Rician distribution.</li> </ul> </li> <li> <p>Applications:</p> <ul> <li>Environments with a strong LOS component (e.g., highways, rural areas).</li> </ul> </li> <li> <p>PDF:   $$   f_R(r) = \\frac{r}{\\sigma^2} e^{-(r^2 + A^2) / (2\\sigma^2)} I_0\\left(\\frac{Ar}{\\sigma^2}\\right), \\quad r \\geq 0,   $$</p> </li> </ul> <p>where \\(A\\) denotes amplitude of the LOS component, and \\(I_0\\) denotes modified Bessel function of the first kind.</p>"},{"location":"channel_models/#134-log-normal-shadowing-model","title":"1.3.4 Log-Normal Shadowing Model","text":"<ul> <li> <p>Description:</p> <ul> <li>Models large-scale signal variations due to shadowing.</li> <li>Shadowing effects are modeled as a Gaussian random variable in dB scale.</li> </ul> </li> <li> <p>Path Loss with Shadowing:   $$   PL(d) = PL_0 + 10\\beta \\log_{10}(d/d_0) + X_\\sigma,   $$</p> </li> </ul> <p>where \\(PL_0\\) denotes path loss at reference distance \\(d_0\\), and \\(X_\\sigma\\) denotes zero-mean Gaussian random variable with standard deviation \\(\\sigma\\).</p>"},{"location":"channel_models/#14-python-simulation","title":"1.4 Python Simulation","text":"<p>The following Python code demonstrates the simulation of common channel models.</p>"},{"location":"channel_models/#large-scale-path-loss-simulation","title":"Large-scale Path Loss Simulation","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef free_space_path_loss(fc, dist, Gt=1, Gr=1):\n    \"\"\"\n    Computes the free-space path loss (FSPL).\n\n    Args:\n        fc (float): Carrier frequency in Hz.\n        dist (float or ndarray): Distance between base station and mobile station in meters.\n        Gt (float, optional): Transmitter gain. Defaults to 1.\n        Gr (float, optional): Receiver gain. Defaults to 1.\n\n    Returns:\n        float or ndarray: Path loss in dB.\n    \"\"\"\n    lamda = 3e8 / fc  # Wavelength in meters\n    tmp = lamda / (4 * np.pi * dist)  # Free-space propagation factor\n    if Gt &gt; 0:\n        tmp *= np.sqrt(Gt)\n    if Gr &gt; 0:\n        tmp *= np.sqrt(Gr)\n    PL = -20 * np.log10(tmp)  # Convert to dB\n    return PL\n\n\ndef log_distance_or_shadowing_path_loss(fc, d, d0, n, sigma=0):\n    \"\"\"\n    Computes the log-distance or log-normal shadowing path loss.\n\n    Args:\n        fc (float): Carrier frequency in Hz.\n        d (float or ndarray): Distance between base station and mobile station in meters.\n        d0 (float): Reference distance in meters.\n        n (float): Path loss exponent.\n        sigma (float, optional): Standard deviation for shadowing in dB. Defaults to 0.\n\n    Returns:\n        float or ndarray: Path loss in dB.\n    \"\"\"\n    lamda = 3e8 / fc  # Wavelength in meters\n    PL = -20 * np.log10(lamda / (4 * np.pi * d0)) + 10 * n * np.log10(d / d0)  # Log-distance model\n    if sigma &gt; 0:\n        PL += sigma * np.random.randn(*np.shape(d))  # Add shadowing\n    return PL\n\n\ndef simulate_path_loss():\n    \"\"\"\n    Simulates and plots path loss for free-space, log-distance, and log-normal shadowing models.\n    \"\"\"\n    fc = 1.5e9  # Carrier frequency in Hz\n    d0 = 100  # Reference distance in meters\n    sigma = 3  # Shadowing standard deviation in dB\n    distance = np.array([i**2 for i in range(1, 32, 2)])  # Quadratic distance scale\n    Gt = [1, 1, 0.5]  # Transmitter gain values\n    Gr = [1, 0.5, 0.5]  # Receiver gain values\n    Exp = [2, 3, 6]  # Path loss exponents\n\n    # Compute path loss for each model\n    y_Free = np.array([free_space_path_loss(fc, distance, Gt[i], Gr[i]) for i in range(3)])\n    y_logdist = np.array([log_distance_or_shadowing_path_loss(fc, distance, d0, Exp[i]) for i in range(3)])\n    y_lognorm = np.array([log_distance_or_shadowing_path_loss(fc, distance, d0, Exp[0], sigma) for _ in range(3)])\n\n    # Plot Free Space Path Loss\n    plt.subplot(131)\n    for i in range(3):\n        plt.semilogx(distance, y_Free[i], label=f\"Gt={Gt[i]}, Gr={Gr[i]}\")\n    plt.grid(True)\n    plt.title(f\"Free Space Path Loss, fc={fc/1e6:.1f} MHz\")\n    plt.xlabel(\"Distance [m]\")\n    plt.ylabel(\"Path Loss [dB]\")\n    plt.legend()\n\n    # Plot Log-Distance Path Loss\n    plt.subplot(132)\n    for i in range(3):\n        plt.semilogx(distance, y_logdist[i], label=f\"n={Exp[i]}\")\n    plt.grid(True)\n    plt.title(f\"Log-Distance Path Loss, fc={fc/1e6:.1f} MHz\")\n    plt.xlabel(\"Distance [m]\")\n    plt.ylabel(\"Path Loss [dB]\")\n    plt.legend()\n\n    # Plot Log-Normal Shadowing Path Loss\n    plt.subplot(133)\n    for i in range(3):\n        plt.semilogx(distance, y_lognorm[i], label=f\"path {i+1}\")\n    plt.grid(True)\n    plt.title(f\"Log-Normal Path Loss, fc={fc/1e6:.1f} MHz, \u03c3={sigma} dB\")\n    plt.xlabel(\"Distance [m]\")\n    plt.ylabel(\"Path Loss [dB]\")\n    plt.legend()\n\n    plt.tight_layout()\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    simulate_path_loss()\n</code></pre>"},{"location":"channel_models/#small-scale-fading-simulation","title":"Small-scale Fading Simulation","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef rayleigh_channel(L):\n    \"\"\"\n    Generates Rayleigh fading channel realizations.\n\n    Args:\n        L (int): Number of channel realizations.\n\n    Returns:\n        ndarray: Rayleigh fading channel vector of size (L,).\n    \"\"\"\n    real_part = np.random.normal(0, 1, L)  # Real part of the channel\n    imag_part = np.random.normal(0, 1, L)  # Imaginary part of the channel\n    H = (real_part + 1j * imag_part) / np.sqrt(2)  # Normalize\n    return H\n\n\ndef rician_channel(K_dB, L):\n    \"\"\"\n    Generates Rician fading channel realizations.\n\n    Args:\n        K_dB (float): Rician K-factor in dB.\n        L (int): Number of channel realizations.\n\n    Returns:\n        ndarray: Rician fading channel vector of size (L,).\n    \"\"\"\n    K = 10 ** (K_dB / 10)  # Convert K-factor from dB to linear scale\n    rayleigh = rayleigh_channel(L)  # Rayleigh component\n    los_component = np.sqrt(K / (K + 1))  # Line-of-sight (LOS) component\n    scattered_component = np.sqrt(1 / (K + 1)) * rayleigh  # Scattered component\n    H = los_component + scattered_component\n    return H\n\n\ndef plot_fading_channels():\n    \"\"\"\n    Simulates and plots the amplitude distribution of Rayleigh and Rician fading channels.\n    \"\"\"\n    N = 200000  # Number of channel realizations\n    level = 30  # Number of histogram bins\n    K_dB = [-40, 15]  # Rician K-factors in dB\n\n    # Generate Rayleigh fading channel\n    rayleigh_ch = rayleigh_channel(N)\n    temp, x = np.histogram(np.abs(rayleigh_ch), bins=level, density=True)\n    plt.plot(x[:-1], temp, 'k-s', label='Rayleigh')\n\n    # Generate Rician fading channels\n    for i, k in enumerate(K_dB):\n        rician_ch = rician_channel(k, N)\n        temp, x = np.histogram(np.abs(rician_ch), bins=level, density=True)\n        plt.plot(x[:-1], temp, 'k-o' if i == 0 else 'k-^', label=f'Rician, K={k} dB')\n\n    # Plot customization\n    plt.xlabel('Amplitude')\n    plt.ylabel('Occurrence')\n    plt.legend()\n    plt.grid(True)\n    plt.title('Amplitude Distribution of Fading Channels')\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    plot_fading_channels()\n</code></pre>"},{"location":"channel_models/#15-conclusion","title":"1.5 Conclusion","text":"<p>Wireless channel modeling is a critical step in understanding and designing robust communication systems. From basic free-space models to advanced fading and shadowing models, these tools enable accurate performance analysis and system optimization. Through simulation, engineers can gain insights into real-world channel behaviors and test algorithms under realistic conditions.</p>"},{"location":"channel_models/#references","title":"References","text":"<ul> <li>Cho, Yong Soo, Jaekwon Kim, Won Y. Yang, and Chung G. Kang. MIMO-OFDM wireless communications with MATLAB. John Wiley &amp; Sons, 2010.</li> </ul>"}]}